<!DOCTYPE html>
<html lang="en">
<head>
    <title>Pepper's Ghost Weather Display</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html {
            height: 100%;
        }

        body {
            perspective: 1000px;
            background: black;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            margin: 0;
            height: 100%;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Base styles for text */
        .overlay-text {
            position: absolute;
            font-size: 16px;
            text-align: center;
            padding: 10px 20px;
            border-radius: 8px;
            pointer-events: none;
            width: 200px;
            transform-style: preserve-3d;
        }

        #weather-text {
            left: 50%;
            transform: translateX(-50%) rotateY(180deg);
        }

        /* Button styles */
        .transform-button {
            position: absolute;
            bottom: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            z-index: 1000; /* Ensure buttons are on top */
        }

        .transform-button:hover {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <!-- Three.js container -->
    <div id="container"></div>

    <!-- Overlay text elements -->
    <div id="weather-text" class="overlay-text">Loading weather...</div>

    <!-- Transformation buttons -->
    <button id="transformButton1" class="transform-button" style="left: 20%;">Transform 1</button>
    <button id="transformButton2" class="transform-button" style="left: 35%;">Transform 2</button>
    <button id="transformButton3" class="transform-button" style="left: 50%;">Transform 3</button>
    <button id="transformButton4" class="transform-button" style="left: 65%;">Transform 4</button>

    <script type="importmap">
        {
            "imports": {
                "three": "./build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PeppersGhostEffect } from 'three/addons/effects/PeppersGhostEffect.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let container = document.getElementById('container');
        let camera, scene, renderer, effect;
        let group;
        let model; // Variable to store the loaded model
        let particleSystem;

        init();
        fetchWeather();

        function init() {
            // Set up the camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);

            // Create the scene
            scene = new THREE.Scene();

            // Create a group for organizing objects in the scene
            group = new THREE.Group();
            scene.add(group);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 4);
            scene.add(ambientLight);

            // Add a directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 6);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Load the GLB model
            const loader = new GLTFLoader();
            loader.load('rain.glb', function (gltf) {
                model = gltf.scene; // Store the model in the variable
                model.scale.set(.1, .1, .1);
                model.position.set(0, 0, 0);
                group.add(model);
            });

            // Particle system setup
            const particleCount = 200; // Reduced number of particles
            const particles = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 1);
            const particleColors = new Float32Array(particleCount * 1);

            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = (Math.random() - 0.5) * 50; // Smaller area
                particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 50;

                particleColors[i * 3] = Math.random();
                particleColors[i * 3 + 1] = Math.random();
                particleColors[i * 3 + 2] = Math.random();
            }

            particles.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: .5, // Smaller particles
                vertexColors: true,
                transparent: true,
                opacity: 0.3, // 50% transparency
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(particles, particleMaterial);
            group.add(particleSystem);

            // Set up the renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            effect = new PeppersGhostEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);
            effect.cameraDistance = 5;

            // Handle window resizing
            onWindowResize();
            window.addEventListener('resize', onWindowResize);

            // Add event listeners for transformation buttons
            document.getElementById('transformButton1').addEventListener('click', () => transformModel(1));
            document.getElementById('transformButton2').addEventListener('click', () => transformModel(2));
            document.getElementById('transformButton3').addEventListener('click', () => transformModel(3));
            document.getElementById('transformButton4').addEventListener('click', () => transformModel(4));
        }

        function onWindowResize() {
            let { innerWidth, innerHeight } = window;
            if (innerWidth < innerHeight) {
                container.style.top = `${Math.floor((innerHeight - innerWidth) / 2)}px`;
                container.style.height = `${innerWidth}px`;
                innerHeight = innerWidth;
            } else {
                container.style.top = '0px';
                container.style.height = '100%';
            }
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(innerWidth, innerHeight);
            renderer.setSize(innerWidth, innerHeight);

            const top = window.innerHeight / 2 + innerHeight / 6;
            document.getElementById('weather-text').style.bottom = `${top}px`;
        }

        function animate() {
            group.rotation.y += 0.01; // Rotate the group for animation

            // Update particle positions (subtle movement)
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < positions.length / 3; i++) {
                positions[i * 3] += (Math.random() - 0.5) * 0.05; // Slower movement
                positions[i * 3 + 1] += (Math.random() - 0.5) * 0.05;
                positions[i * 3 + 2] += (Math.random() - 0.5) * 0.05;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            effect.render(scene, camera);
        }

        function transformModel(transformationType) {
            if (!model) return;

            switch (transformationType) {
                case 1:
                    model.scale.set(3, 3, 3);
                    break;
                case 2:
                    model.rotation.y += Math.PI / 2;
                    break;
                case 3:
                    model.position.set(5, 0, 0);
                    break;
                case 4:
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material.color.set(Math.random() * 0xffffff); // Random color
                        }
                    });
                    break;
                default:
                    console.log("Unknown transformation type");
            }
        }

        async function fetchWeather() {
            try {
                const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=37.7749&longitude=-122.4194&current_weather=true');
                const data = await response.json();
                const temp = data.current_weather.temperature;
                const condition = data.current_weather.weathercode; // Weather code for conditions

                let conditionText = getWeatherCondition(condition);
                let weatherText = `San Francisco: ${temp}Â°C - ${conditionText}`;

                document.getElementById('weather-text').innerText = weatherText;
            } catch (error) {
                console.error("Failed to fetch weather:", error);
            }
        }

        function getWeatherCondition(code) {
            // Weather codes based on Open-Meteo documentation
            const weatherConditions = {
                0: "Clear sky",
                1: "Mainly clear",
                2: "Partly cloudy",
                3: "Overcast",
                45: "Fog",
                48: "Depositing rime fog",
                51: "Drizzle (Light)",
                53: "Drizzle (Moderate)",
                55: "Drizzle (Dense)",
                61: "Rain (Slight)",
                63: "Rain (Moderate)",
                65: "Rain (Heavy)",
                80: "Rain showers (Slight)",
                81: "Rain showers (Moderate)",
                82: "Rain showers (Violent)",
                95: "Thunderstorm (Slight/Moderate)",
                96: "Thunderstorm with hail (Slight)",
                99: "Thunderstorm with hail (Heavy)"
            };
            return weatherConditions[code] || "Unknown";
        }
    </script>
</body>
</html>